# QiwebProgrammingLearning
# qiweb编程学习记项目
## 在线绘图工具：https://www.draw.io 项目中xml图都用此打开可直接连接github编辑
<
面试，总结问题
==============2018- 11 -12
1-Jvm何时回收Gc root
# JVM的内存模型
1.程序计数器
程序计数器是每个线程所私有的
2.Java栈
3、本地方法栈
Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的
4.堆
Java中的堆是用来存储对象本身的以及数组（当然，数组引用是存放在Java栈中的）
5.方法区
　　方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码
说的简单点，栈里面存放的是基本的数据类型和引用，而堆里面则是存放各种对象实例的。

2-Jdk8跟之前版本功能jvm和性能？
3-技术架构拓扑图
4-业务模型画一下？
5-数据库分了分表？
6-遇到最大的困难和挑战是？
7-数据库联合索引和命中？
8-多系统之间一致性解决方案有哪些？
9-消息队列Kafka  rabbitmq
10-设计线程池，主线程等待子线程

==================2018-11-13
性能优化
数据库优化
多线程设计，
解决多系统一致性
Jvm 原理
# Jdk1.8新增内容十大新特性
1.Lambda表达式
2.Stream函数式操作流元素集合
3.接口新增：默认方法与静态方法
4.方法引用,与Lambda表达式联合使用
5.引入重复注解
6.类型注解
7.最新的Date/Time API (JSR 310)
8.新增base64加解密API
9.数组并行（parallel）操作
10.JVM的PermGen空间被移除：取代它的是Metaspace（JEP 122）元空间
http://www.cnblogs.com/dennyzhangdd/p/6722445.html

通讯协议，webservice ftp http
团队管理，
自我介绍，
消息队列mq
Html 5
# 多线程带来了哪些编程复杂性？
共享数据访问（锁）
互斥锁 读写锁 信号量
# 为什么线程过多会带来性能问题？
线程挂起和恢复，争抢资源
内存抖动
持锁的线程挂起
限制活动线程的个数不超过硬件线程的个数

# Java并发问题--乐观锁与悲观锁以及乐观锁的一种实现方式-CAS
首先介绍一些乐观锁与悲观锁:

## 悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。

## 乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。

# 分布式订单号 系统高并发分布式订单号生成策略 唯一
## 1.UUID  唯一识别码，16个字节 （128位）

　　组成部分：当前日期+时间+时钟的序列+mac地址 
## 2.snowflake（雪花twitter开源 分布式id算法）

41字节毫秒+10字节的机器id+10版本号，国内有很多平台有将其实现和优化
## 3.redis 集群

格式：12位=年2位+当年第几天3+小时2+自增5
Redis 雪奔 内存数据库解决高并发性能
# redis五大类型用法
Redis五大类型:字符串（String）、哈希/散列/字典（Hash）、列表（List）、集合（Set）、有序集合（sorted set）
# Java中常用的加密算法小结
 
## 散列算法（单向散列，不可逆）
MD5（Message Digest Algorithm 5）
SHA（Secure Hash Algorithm）
 
## 对称加密（加密解密使用同一密钥，速度快）
DES
3DES
AES
 
## 非对称加密（公钥加密，私钥解密，可以签名，更安全）
RSA
ECC
===================2018-11-14
静态类new会导致内存爆满
文件生成后在内存中不会释放  需要分配固定空间
Mq对比
===================2018-11-15
分库分表分片
Jvm底层架构
高并发高可用实际问题解决

# 队列消息模型的特点
1消息生产者将消息发送到Queue中，然后消息消费者监听Queue并接收消息；
2消息被确认消费以后，就会从Queue中删除，所以消息消费者不会消费到已经被消费的消息；
3Queue支持存在多个消费者，但是对某一个消息而言，只会有一个消费者成功消费。
常用的MQ中间件产品 ActiveMQ、RabbitMQ、RocketMQ等
1、Producer生成消息并发送给MQ（同步、异步）；
2、MQ接收消息并将消息数据持久化到消息存储（持久化操作为可选配置）；
3、MQ向Producer返回消息的接收结果（返回值、异常）；
4、Consumer监听并消费MQ中的消息；
5、Consumer获取到消息后执行业务处理；
6、Consumer对已成功消费的消息向MQ进行ACK确认（确认后的消息将从MQ中删除）

# HTTP请求的生命周期
<pre>
## filename: socket服务端 
1. 监听IP和服务端口(42.121.252.58,80) 
        while True: 
            用户 = 等待用户链接 
            3. 收到socket客户端发送的数据 
            4. 响应数据 
            断开链接 
 
 
## filename: socket客户端 
2. 浏览器输入网址 www.cnblogs.com 通过DNS域名解析为IP地址及端口(42.121.252.58,80) 
    socket进行链接  
        sk = socket.socket((42.121.252.58,80)) 
        sk.connect() 
    发送请求数据 
        sk.send('xxxxx') 
         
5. 接收客户端数据 
 
6. 断开链接
</pre>
# 如何设计一个程序 软件设计要素
需求理解--概要设计--详细设计--编码--测试--交付--验收--维护
结构设计：定义软件系统各主要部件之间的关系。
数据设计：将模型转换成数据结构的定义。
接口设计：软件内部，软件和操作系统间以及软件和人之间如何通信。
过程设计：系统结构部件转换成软件的过程描述。
# 我最擅长那一块
就说你逻辑好，懂业务，听的懂业务需求，可以根据业务需求用最简单的代码，完成需要的功能
擅长使用各种工具 ，定位和解决项目中遇到的实际问题，
性能分析方法
# Kafka消息 rabbitmq中间件
rabbitmq 比kafka可靠，kafka更适合IO高吞吐的处理，比如ELK日志收集
<br>
# 熔断器原理<br>
## 使用Hystrix预防服务雪崩<br>
在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。<br>
较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。
如何防止宕机
加密算法
# 微服务系列：微服务拆分的原则与步骤 怎么拆分微服务
拆分原则：
      单一职责、服务粒度适中、考虑团队结构、以业务模型切入、演进式拆分、避免环形依赖和双向依赖
拆分步骤：
      分析业务模型、确定服务边界、模块拆分、数据库拆分
# 其他思考
你对自己都不了解的话，让面试官怎么了解你呢？
你做过的项目架构有哪些亮点？分布式？高并发？大数据？
你平时开发最多的模块是什么？工作流？业务处理？通用模块？逻辑算法？
你有没有在公司比较重要的项目中担任主要角色？
你有没有在项目很紧急或者项目有难题的情况下，按时保质保量的完成开发任务？
</pre>
