# QiwebProgrammingLearning
# qiweb编程学习记项目
## 在线绘图工具：https://www.draw.io 项目中xml图都用此打开可直接连接github编辑
<
面试，总结问题
==============2018- 11 -12
# 1-Jvm何时回收Gc root java--GC Root有哪些
GC管理的主要区域是Java堆，一般情况下只针对堆进行垃圾回收。方法区、栈和本地方法区不被GC所管理,因而选择这些区域内的对象作为GC roots,被GC roots引用的对象不被GC回收。
简而言之，GC是将java的无用的堆对象进行清理，释放内存，以免发生内存泄露
##  常见回收算法
1、标记-清除算法 
2、复制算法：（新生代的GC）
3、标记-整理算法：（老年代的GC）
4、分代收集算法：
# JVM的内存模型
1.程序计数器
程序计数器是每个线程所私有的
2.Java栈
3、本地方法栈
Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的
4.堆
Java中的堆是用来存储对象本身的以及数组（当然，数组引用是存放在Java栈中的）
5.方法区
　　方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码
说的简单点，栈里面存放的是基本的数据类型和引用，而堆里面则是存放各种对象实例的。

2-Jdk8跟之前版本功能jvm和性能？
3-技术架构拓扑图
4-业务模型画一下？
# 5-数据库分了分表？分库分表分区

## 分库，可以按照业务分库，分流数据库并发压力 
.我们当时是把查询库和系统库(增删改比较频繁的表)分开了，这样如果有大查询，不影响系统库
 分表，刚才说了，索引适合应对百万级别的数据量，千万级别数据量使用的好，勉强也能凑合，但如果是上亿级别的数据量，索引就无能为力了，因为单索引文件可能就已经上百兆或者更多了
## 分表的方法有很多种

        a、如果这个业务是有流程的，那么我们通常会设计一个历史表或者归档表，用来存放历史数据，这样能保证实时数据效率比较高

        b、针对某一张大表，可以根据查询条件分成多张表，比如时间。但是需要union多张表，而且跨表没法支持索引 如mycat，也是支持分表的
## 分区
’区不一样，一张大表进行分区后，他还是一张表，不会变成二张表，但是他存放数据的区块变多了
也是将相应规则的数据放在一起，唯一不同的是分区你只需要设定好分区规则，插入的数据会被自动插入到指定的区里
分表和分区不矛盾，可以相互配合的
## 读写分离 数据库引擎

# 6-遇到最大的困难和挑战是？
如何把团队培养的足够强大，
遇到技术难题，需要去挑战新的系统压力，去解决
7-数据库联合索引和命中？
8-多系统之间一致性解决方案有哪些？

10-设计线程池，主线程等待子线程

==================2018-11-13
性能优化
数据库优化
多线程设计，
解决多系统一致性
Jvm 原理
# Jdk1.8新增内容十大新特性
1.Lambda表达式
2.Stream函数式操作流元素集合
3.接口新增：默认方法与静态方法
4.方法引用,与Lambda表达式联合使用
5.引入重复注解
6.类型注解
7.最新的Date/Time API (JSR 310)
8.新增base64加解密API
9.数组并行（parallel）操作
10.JVM的PermGen空间被移除：取代它的是Metaspace（JEP 122）元空间
http://www.cnblogs.com/dennyzhangdd/p/6722445.html

通讯协议，webservice ftp http
团队管理，
自我介绍，
消息队列mq
Html 5
# 多线程带来了哪些编程复杂性？
共享数据访问（锁）
互斥锁 读写锁 信号量
# 为什么线程过多会带来性能问题？
线程挂起和恢复，争抢资源
内存抖动
持锁的线程挂起
限制活动线程的个数不超过硬件线程的个数

# Java并发问题--乐观锁与悲观锁以及乐观锁的一种实现方式-CAS
首先介绍一些乐观锁与悲观锁:

## 悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。

## 乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。

# 分布式订单号 系统高并发分布式订单号生成策略 唯一
## 1.UUID  唯一识别码，16个字节 （128位）

　　组成部分：当前日期+时间+时钟的序列+mac地址 
## 2.snowflake（雪花twitter开源 分布式id算法）

41字节毫秒+10字节的机器id+10版本号，国内有很多平台有将其实现和优化
## 3.redis 集群

格式：12位=年2位+当年第几天3+小时2+自增5
Redis 雪奔 内存数据库解决高并发性能
# redis五大类型用法
Redis五大类型:字符串（String）、哈希/散列/字典（Hash）、列表（List）、集合（Set）、有序集合（sorted set）
# Java中常用的加密算法小结
 
## 散列算法（单向散列，不可逆）
MD5（Message Digest Algorithm 5）
SHA（Secure Hash Algorithm）
 
## 对称加密（加密解密使用同一密钥，速度快）
DES
3DES
AES
 
## 非对称加密（公钥加密，私钥解密，可以签名，更安全）
RSA
ECC
===================2018-11-14
静态类new会导致内存爆满
文件生成后在内存中不会释放  需要分配固定空间
Mq对比
===================2018-11-15
分库分表分片
Jvm底层架构
高并发高可用实际问题解决

# 队列消息模型的特点
1消息生产者将消息发送到Queue中，然后消息消费者监听Queue并接收消息；
2消息被确认消费以后，就会从Queue中删除，所以消息消费者不会消费到已经被消费的消息；
3Queue支持存在多个消费者，但是对某一个消息而言，只会有一个消费者成功消费。
常用的MQ中间件产品 ActiveMQ、RabbitMQ、RocketMQ等
1、Producer生成消息并发送给MQ（同步、异步）；
2、MQ接收消息并将消息数据持久化到消息存储（持久化操作为可选配置）；
3、MQ向Producer返回消息的接收结果（返回值、异常）；
4、Consumer监听并消费MQ中的消息；
5、Consumer获取到消息后执行业务处理；
6、Consumer对已成功消费的消息向MQ进行ACK确认（确认后的消息将从MQ中删除）

# HTTP请求的生命周期
<pre>
## filename: socket服务端 
1. 监听IP和服务端口(42.121.252.58,80) 
        while True: 
            用户 = 等待用户链接 
            3. 收到socket客户端发送的数据 
            4. 响应数据 
            断开链接 
 
 
## filename: socket客户端 
2. 浏览器输入网址 www.cnblogs.com 通过DNS域名解析为IP地址及端口(42.121.252.58,80) 
    socket进行链接  
        sk = socket.socket((42.121.252.58,80)) 
        sk.connect() 
    发送请求数据 
        sk.send('xxxxx') 
         
5. 接收客户端数据 
 
6. 断开链接
</pre>
# 如何设计一个程序 软件设计要素
需求理解--概要设计--详细设计--编码--测试--交付--验收--维护
结构设计：定义软件系统各主要部件之间的关系。
数据设计：将模型转换成数据结构的定义。
接口设计：软件内部，软件和操作系统间以及软件和人之间如何通信。
过程设计：系统结构部件转换成软件的过程描述。
# 我最擅长那一块
就说你逻辑好，懂业务，听的懂业务需求，可以根据业务需求用最简单的代码，完成需要的功能
擅长使用各种工具 ，定位和解决项目中遇到的实际问题，
性能分析方法
# Kafka消息 rabbitmq中间件
rabbitmq 比kafka可靠，kafka更适合IO高吞吐的处理，比如ELK日志收集
<br>
# 熔断器原理<br>
## 使用Hystrix预防服务雪崩<br>
在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。<br>
较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。
如何防止宕机


# 数据库表添加索引对性能的影响
## .索引的优点
可以大大加快数据的检索速度，这也是创建索引的最主要的原因。、可以加速表和表之间的连接，
通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
## .索引的缺点
创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
索引需要占物理空间
当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
# 防止服务器宕机时MySQL数据丢失的几种方案
数据库集群，主从复制   监控工具，报警日志
# 微服务系列：微服务拆分的原则与步骤 怎么拆分微服务
拆分原则：
      单一职责、服务粒度适中、考虑团队结构、以业务模型切入、演进式拆分、避免环形依赖和双向依赖
拆分步骤：
      分析业务模型、确定服务边界、模块拆分、数据库拆分
# 其他思考
你对自己都不了解的话，让面试官怎么了解你呢？
你做过的项目架构有哪些亮点？分布式？高并发？大数据？
你平时开发最多的模块是什么？工作流？业务处理？通用模块？逻辑算法？
你有没有在公司比较重要的项目中担任主要角色？
你有没有在项目很紧急或者项目有难题的情况下，按时保质保量的完成开发任务？
</pre>


# Spring Cloud各个组件相互配合，合作支持了一套完整的微服务架构。 

其中Eureka负责服务的注册与发现，很好将各服务连接起来
Hystrix 负责监控服务之间的调用情况，连续多次失败进行熔断保护。
feign 服务间调用Ribbon 服务集群负载均衡
Spring Cloud Config 提供了统一的配置中心服务
当配置文件发生变化的时候，Spring Cloud Bus 负责通知各服务去获取最新的配置信息
所有对外的请求和服务，我们都通过Zuul来进行转发，起到API网关的作用
最后我们使用Sleuth+Zipkin将所有的请求数据记录下来，方便我们进行后续分析
Spring Cloud从设计之初就考虑了绝大多数互联网公司架构演化所需的功能，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等。

